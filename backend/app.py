import argparse
from flask import Flask, request
from flask_cors import CORS
from pyngrok import ngrok
import json
import logging

from pymongo import MongoClient

from model.temporal_fusion_transformer import TFT

from utils import classify_yaha_mala, retrieve_ts_data, get_forecast_summary
import constants

import warnings
warnings.filterwarnings('ignore')

# Parse arguments for running with or without ngrok
parser = argparse.ArgumentParser(description='Run Flask app with or without Ngrok')
parser.add_argument('--ngrok', action='store_true', help='Run with Ngrok')
args = parser.parse_args()

# Connect to MongoDB
client = MongoClient(constants.CONNECTION_STRING)

# Initialize Flask app and enable CORS
app = Flask(__name__)
CORS(app)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s [%(asctime)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# Define endpoint for generating forecasts
@app.route('/generate-forecasts', methods=['POST'])
def generate_forecasts():
    try:
        data = request.get_json()

        # Retrieve selected time series data from MongoDB
        selected_series = data.get('selected_series')
        if selected_series is not None:
            date_from = data['date_from']
            date_to = data['date_to']
            df = retrieve_ts_data(client, selected_series, date_from, date_to)

            # Create and preprocess TFT model
            logging.info('Successfully created TFT')
            tft_model = TFT(data=df)
            logging.info('Successfully created tft')
            tft_model.preprocess_data(df.drop(columns=['date'], axis=1).columns, classify_yaha_mala)
            logging.info('Successfully preprocessed data')

            # Create time series dataset and dataloaders
            tft_model.create_ts_dataset()
            tft_model.create_dataloaders()
            logging.info('Successfully prepared ts obj. and dataloaders')

            # Configure network and trainer
            tft_model.configure_network_and_trainer(hyperparams=constants.BEST_HYPER_PARAMETERS,
                                                    max_epochs=30)
            logging.info('Successfully configured trainer, model is ready for training!')

            # Train model
            tft_model.fit_network()
            logging.info('Successfully fit model')

            actuals = df.iloc[:, 1].tolist()

            # Generate forecasts and evaluate model performance
            model_results = tft_model.evaluate(actuals=actuals[-12:])

            forecasts = model_results[0]
            forecasted_dates = model_results[1]
            metrics = model_results[2]
            logging.info('Successfully generated forecasts and evaluated model')

            # Return forecast results as JSON response
            return json.dumps(
                {
                    'success': True,
                    'dates': [dt.strftime('%Y-%m-%d') for dt in df['date'].tolist()] + forecasted_dates,
                    'actuals': actuals,
                    'forecasts': forecasts,
                    'summary': get_forecast_summary(forecasts, forecasted_dates),
                    'metrics': metrics
                }), 200

        elif selected_series is None:
            # Handle error if no time series data is provided in request
            error_msg = 'The request does not contain the series to be used'
            logging.error(error_msg)

            return json.dumps(
                {
                    'success': False,
                    'message': error_msg
                }), 400

    except Exception as e:
        logging.error('An error occurred: ' + str(e))
        return json.dumps({'success': False, 'message': str(e)}), 500


if __name__ == '__main__':
    # If the --ngrok argument is passed, use Ngrok to expose the app to the internet
    if args.ngrok:
        try:
            # Set Ngrok authentication token
            ngrok.set_auth_token(constants.NGROK_AUTH_TOKEN)

            # Open an HTTP tunnel with Ngrok on port 5000
            http_tunnel = ngrok.connect(5000)

            # Print the public URL generated by Ngrok
            print(f" * Running on {http_tunnel}")

        except KeyboardInterrupt:
            # Handle Ctrl-C interruption
            print(" Shutting down server.")

            # Terminate the Ngrok process
            ngrok.kill()

        # Run the Flask app on port 5000
        app.run(port=5000)

    # If the --ngrok argument is not passed, simply run the Flask app on port 5000
    else:
        app.run(port=5000, debug=True)